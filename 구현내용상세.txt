===============================================
사자성어 학습 프로그램 구현 내용 상세
===============================================
작성일: 2025-11-14
작성자: loremipsum0116
버전: 1.0
===============================================

1. 개요
-------
요구사항 정의서(RDD)에 명시된 내용을 기반으로 턴제 전투 시스템이 결합된 사자성어
학습 프로그램을 풀스택으로 구현했습니다. 백엔드는 Node.js + Express + MongoDB로,
프론트엔드는 React + TypeScript로 개발했어요.

특히 특허 핵심 로직인 '학습 성과 데이터 기반 데미지 연산' 부분을 중점적으로
구현했습니다.


2. 기술 스택 선정 이유
-----------------------

[백엔드]
- Node.js + Express: 비동기 처리에 강하고, JavaScript 기반이라 프론트엔드와
  언어를 통일할 수 있어서 선택했습니다.
- MongoDB: 사자성어 데이터나 학습 로그처럼 비정형 데이터가 많아서 NoSQL이
  적합하다고 판단했어요. 스키마 변경도 유연하게 할 수 있고요.
- JWT: stateless한 인증 방식이 필요해서 선택. 확장성도 좋고 모바일 앱으로
  확장할 때도 유리합니다.

[프론트엔드]
- React 18: 컴포넌트 기반 개발로 재사용성이 좋고, 생태계가 크다는 장점이 있어요.
- TypeScript: 타입 안정성 때문에 선택. API 응답이나 상태 관리에서 타입 체크가
  되니까 런타임 에러를 많이 줄일 수 있었습니다.
- Vite: CRA보다 빌드 속도가 훨씬 빠르고, 개발 서버 구동도 거의 즉시 되더라고요.
- Zustand: Redux보다 훨씬 간단하면서도 필요한 기능은 다 있어서 선택했습니다.
  보일러플레이트 코드가 거의 없어서 좋았어요.
- TailwindCSS: 유틸리티 클래스 기반이라 빠르게 UI 구현할 수 있었습니다.


3. 데이터베이스 설계
--------------------

총 5개의 컬렉션을 설계했습니다:

[1] Users (사용자)
- 기본 정보: 이메일, 비밀번호(해시), 닉네임, 프로필 이미지
- 게임 진행 상황: clearedStages (클리어한 스테이지 배열)
- 사자 스탯: HP, maxHP, level
- 잠금 해제 콘텐츠: hiddenBoss, infiniteMode, pvpMode
- 설정: 사운드, 알림

비밀번호는 bcrypt로 해싱해서 저장하도록 pre-save 훅을 걸어뒀어요.

[2] Idioms (사자성어 DB)
- idiom_id, hanja, hangul, meaning, example_sentence, base_difficulty
- 현재 50개 샘플 데이터가 들어있고, 난이도별로 균등 분배했습니다.
- 실제 서비스에서는 2,000개까지 확장 가능하게 구조화했어요.

[3] GameStages (게임 스테이지)
- 12지신을 모티브로 한 12개 스테이지 정보
- 각 보스의 이름, HP, 공격력, 설명 등을 저장
- seedData.js에서 초기화 시 자동으로 생성됩니다.

[4] LearningLogs (학습/전투 로그) ★핵심★
- 사용자의 모든 학습 행동을 기록
- action_type: ATTACK(공격), DEFEND(방어), LEARN(학습)
- chosen_difficulty: 선택한 난이도
- is_correct: 정답 여부
- response_time_ms: 응답 시간 (밀리초)
- calculated_damage: 계산된 데미지
→ 이 데이터를 기반으로 통계를 생성하고 학습 패턴을 분석합니다.

[5] PvPMatches (PvP 대전 기록)
- 향후 유저 간 대결 기능을 위한 구조
- 현재는 스키마만 정의해둔 상태


4. 백엔드 API 구현
-------------------

총 5개 라우터로 구성했습니다:

[/api/auth - 인증 관련]
POST /signup - 회원가입
POST /login - 로그인
GET /me - 현재 사용자 정보 조회

JWT 토큰은 7일 유효기간으로 설정했고, 미들웨어에서 자동으로 검증합니다.
401 에러 발생 시 클라이언트에서 자동으로 로그인 페이지로 리다이렉트되게 했어요.

[/api/idioms - 사자성어 관련]
GET / - 사자성어 목록 (난이도 필터, 페이지네이션 지원)
GET /:idiomId - 특정 사자성어 상세
GET /quiz/blank - 빈칸 맞추기 퀴즈 생성
GET /quiz/card-matching - 카드 매칭 퀴즈 생성
POST /learn/submit - 학습 결과 저장

퀴즈 생성 시 MongoDB의 $sample을 활용해서 랜덤 추출하도록 했습니다.
빈칸 위치도 매번 랜덤으로 바뀌게 구현했어요.

[/api/game - 게임/전투 관련] ★핵심★
GET /stages - 전체 스테이지 목록
GET /stages/:stageId - 특정 스테이지 정보
POST /attack - 공격 처리 및 데미지 연산
POST /defend - 방어 처리 및 데미지 감소
POST /clear - 스테이지 클리어 처리
GET /progress - 사용자 진행 상황

/attack 엔드포인트가 가장 중요한데, 여기서 특허 로직인 데미지 연산을 수행합니다.
받은 데이터 (난이도, 정답여부, 응답시간)를 combatCalculator.js의 함수로 넘겨서
최종 데미지를 계산하고, LearningLog에 저장합니다.

[/api/stats - 통계 관련]
GET /user - 전체 통계
GET /stage/:stageId - 스테이지별 통계
GET /recent - 최근 학습 기록
GET /pattern - 학습 패턴 (일별, 시간대별)
GET /wrong-answers - 틀린 문제 목록

집계 쿼리로 난이도별, 액션별 통계를 실시간으로 계산합니다.
나중에 데이터가 많아지면 캐싱이나 배치 처리를 고려해야 할 것 같아요.

[/api/users - 사용자 설정]
PUT /settings - 환경 설정 업데이트
PUT /profile - 프로필 업데이트
PUT /lion-stats - 사자 스탯 업데이트


5. 핵심 로직 구현 (특허 부분)
-------------------------------

server/utils/combatCalculator.js 파일에 모든 전투 연산 로직을 모아뒀습니다.

[공격 데미지 계산 - calculateAttackDamage()]

공식: Final_Damage = (BaseDamage × Accuracy) + BonusDamage

1) BaseDamage (난이도별 기본 데미지)
   - EASY: 10
   - MEDIUM: 20
   - HARD: 30

2) Accuracy (정확도)
   - 정답: 1.0 (100%)
   - 오답: 0.0 (0%)

   즉, 틀리면 아예 데미지가 0이 됩니다.

3) BonusDamage (응답 속도 보너스)
   - 각 난이도마다 제한 시간이 있어요:
     * EASY: 15초
     * MEDIUM: 10초
     * HARD: 5초

   - 제한 시간 내에 빨리 풀수록 보너스가 커집니다 (최대 +10)
   - 계산식: (1 - 응답시간/제한시간) × 10
   - 예) 중급 난이도에서 3초만에 풀었다면:
     (1 - 3000/10000) × 10 = 7점의 보너스

실제로 정답을 맞추고 빠르게 풀면:
- 고급 + 1초 응답 = 30 + 8 = 38 데미지
- 중급 + 5초 응답 = 20 + 5 = 25 데미지
- 초급 + 10초 응답 = 10 + 3.3 = 13 데미지

이렇게 차등 보상이 됩니다.

[방어 데미지 계산 - calculateDefenseDamage()]

공식: Damage_Taken = Base_Boss_Damage × Defense_Multiplier

- 방어 성공: 0.3 (30%만 받음, 70% 감소)
- 방어 실패: 1.0 (100% 그대로 받음)

예를 들어 보스 공격력이 15인데:
- 방어 성공: 15 × 0.3 = 4.5 → 5 데미지
- 방어 실패: 15 × 1.0 = 15 데미지

방어를 성공하면 데미지를 크게 줄일 수 있어서 생존력이 높아집니다.


6. 프론트엔드 구현
-------------------

[상태 관리]

Zustand로 두 개의 스토어를 만들었어요:

1) authStore.ts
- 로그인/로그아웃 처리
- 사용자 정보 저장
- JWT 토큰 관리
- localStorage에 토큰 저장하고, 페이지 새로고침 시 자동으로 인증 체크

2) gameStore.ts
- 현재 스테이지 정보
- 플레이어/보스 HP
- 현재 턴 (player/boss)
- 전투 상태 관리

[페이지 구성]

총 7개 페이지를 구현했습니다:

1) LoginPage / SignupPage
- 간단한 폼 검증 (이메일 형식, 비밀번호 확인 등)
- 에러 메시지 표시
- 로그인 성공 시 자동으로 홈으로 이동

2) HomePage ★메인 화면★
- 4개 메뉴 카드로 구성 (학습, 게임, 통계, 설정)
- 사용자 스탯 표시 (레벨, HP, 클리어 스테이지)
- 잠금 해제된 콘텐츠가 있으면 하단에 표시
- 그라데이션 배경으로 시각적 효과

3) LearningModePage
- 난이도 선택 → 모드 선택 (빈칸/카드) 흐름
- 빈칸 맞추기만 완전 구현 (카드 매칭은 UI만)
- 정답/오답 즉시 피드백
- 다음 문제 자동 로드

4) GameModePage (스테이지 선택)
- 12지신 스테이지를 그리드로 표시
- 클리어한 스테이지는 체크 표시
- 순차적으로 잠금 해제 (이전 스테이지 클리어해야 다음 도전 가능)
- 각 보스의 체력, 공격력 정보 표시
- 진행률 프로그레스 바

5) BattlePage ★가장 복잡한 페이지★
전투 플로우:
  a) 난이도 선택 화면 (초급/중급/고급)
  b) 공격 턴: 문제 풀이 → API 호출로 데미지 계산 → 보스 HP 감소
  c) 보스 턴: 방어 문제 출제 → 성공 여부에 따라 데미지 경감
  d) 승리/패배 처리

- 상단에 플레이어/보스 HP 바를 실시간으로 표시
- 각 난이도별로 아이콘과 설명 (데미지, 제한시간)
- 문제 풀이 화면은 큰 글씨로 가독성 높임
- 선택한 답은 파란색으로 하이라이트
- 정답/오답 피드백 후 2초 딜레이를 줘서 사용자가 확인할 시간 제공
- 보스 HP가 0되면 클리어 처리 후 게임 모드로 복귀

6) StatsPage
- 카드 형태로 주요 지표 4개 표시 (총 문제, 정답, 정확도, 총 데미지)
- 난이도별 상세 통계를 테이블로 구성
- 행동별 통계 (공격/방어/학습) 분리 표시
- 그라데이션 배경으로 통일감

7) SettingsPage
- 토글 스위치로 사운드/알림 on/off
- 설정 저장 버튼 클릭 시 API 호출
- 사용자 기본 정보 표시

[API 서비스 레이어]

client/src/services/api.ts에 모든 API 호출을 모아뒀어요.

- axios 인스턴스 생성
- request interceptor로 모든 요청에 자동으로 JWT 토큰 추가
- response interceptor로 401 에러 시 자동 로그아웃 & 로그인 페이지 이동
- 각 엔드포인트별로 함수 분리 (authAPI, idiomAPI, gameAPI, statsAPI, userAPI)
- TypeScript 타입 지정으로 안전성 확보


7. 주요 기능 동작 흐름
-----------------------

[회원가입 → 로그인 → 메인 진입]
1. 사용자가 이메일, 비밀번호, 닉네임 입력
2. POST /api/auth/signup 호출
3. 백엔드에서 bcrypt로 비밀번호 해싱 후 저장
4. JWT 토큰 발급 및 반환
5. 클라이언트는 토큰을 localStorage에 저장
6. authStore에 사용자 정보 저장
7. 자동으로 홈 화면(/)으로 리다이렉트

[학습 모드 플로우]
1. 난이도 선택 (EASY/MEDIUM/HARD)
2. 빈칸 맞추기 선택
3. GET /api/idioms/quiz/blank?difficulty=MEDIUM 호출
4. 랜덤 사자성어 + 빈칸 + 4지선다 옵션 받음
5. 타이머 시작 (startTime 기록)
6. 사용자가 답 선택 후 제출
7. POST /api/idioms/learn/submit으로 결과 전송
8. 정답/오답 피드백 표시
9. 다음 문제 버튼 → 3번으로 돌아감

[턴제 전투 플로우] ★핵심★
1. 스테이지 선택 → /battle/:stageId로 진입
2. 스테이지 정보 로드 (보스 HP, 공격력 등)
3. 플레이어 HP 100, 보스 HP 초기화

[공격 턴]
4. 난이도 선택 화면 표시
5. 사용자가 난이도 선택 (예: 중급)
6. GET /api/idioms/quiz/blank?difficulty=MEDIUM
7. 문제 화면 + 타이머 시작
8. 사용자가 답 선택 후 제출
9. POST /api/game/attack로 데이터 전송:
   {
     stageId: 5,
     idiomId: 23,
     difficulty: 'MEDIUM',
     isCorrect: true,
     responseTimeMs: 3500
   }
10. 백엔드에서 데미지 계산:
    - baseDamage = 20 (중급)
    - accuracy = 1.0 (정답)
    - bonusDamage = (1 - 3500/10000) * 10 = 6.5
    - finalDamage = 20 * 1.0 + 6.5 = 26.5 → 26
11. 응답으로 { damage: 26, isCorrect: true, message: '정답입니다!' }
12. 보스 HP에서 26 차감
13. 보스 HP > 0이면 방어 턴으로

[방어 턴]
14. "보스의 공격!" 메시지
15. 방어 문제 출제 (난이도 EASY 고정)
16. 사용자가 방어 문제 풀이
17. POST /api/game/defend로 전송:
    {
      stageId: 5,
      idiomId: 12,
      defenseSuccess: true,
      responseTimeMs: 4200,
      bossDamage: 18
    }
18. 백엔드에서 데미지 계산:
    - baseBossDamage = 18
    - defenseMultiplier = 0.3 (방어 성공)
    - damageTaken = 18 * 0.3 = 5.4 → 5
19. 플레이어 HP에서 5 차감
20. 플레이어 HP > 0이면 다시 4번 (공격 턴)으로

[승리 처리]
21. 보스 HP가 0이 되면
22. POST /api/game/clear { stageId: 5 }
23. 사용자의 clearedStages 배열에 5 추가
24. 12개 모두 클리어 시 unlockedContent 활성화
25. "Stage 5 클리어!" 알림
26. 게임 모드 화면으로 복귀

[통계 조회]
1. StatsPage 진입
2. GET /api/stats/user 호출
3. 백엔드에서 LearningLog 집계:
   - 전체 문제 수
   - 정답 수 / 오답 수
   - 정확도 계산
   - 난이도별 집계
   - 액션별 집계
4. 결과를 카드와 테이블 형태로 표시


8. 보안 및 에러 처리
--------------------

[보안]
- 비밀번호는 bcrypt로 salt round 10으로 해싱
- JWT secret은 환경변수로 분리 (.env)
- 민감한 정보(비밀번호)는 API 응답에서 제외 (.select('-password'))
- CORS 설정으로 허용된 origin만 접근 가능
- SQL Injection 위험 없음 (NoSQL이지만 입력 검증은 함)

[에러 처리]
- try-catch로 모든 비동기 함수 감쌈
- 에러 발생 시 적절한 HTTP 상태 코드 반환
- 클라이언트에서 에러 메시지 사용자 친화적으로 표시
- 401 에러는 자동 로그아웃 처리
- 네트워크 에러 시 재시도 로직은 없음 (추후 구현 필요)


9. 데이터 초기화
-----------------

server/utils/seedData.js 스크립트로 초기 데이터를 넣을 수 있어요.

실행 방법:
```
node server/utils/seedData.js
```

자동으로 수행되는 작업:
1. 기존 Idioms, GameStages 컬렉션 삭제
2. idioms.json 파일에서 사자성어 50개 로드
3. MongoDB에 삽입
4. 12지신 스테이지 데이터 삽입 (쥐, 소, 호랑이, ... 돼지)
5. 각 보스마다 적절한 HP와 공격력 설정

초기 데이터:
- 사자성어: 50개 (난이도별 균등)
- 스테이지: 12개 (점점 어려워짐)


10. 미구현 / 향후 과제
----------------------

시간 관계상 다음 기능들은 구조만 잡아두고 완전히 구현하지 못했습니다:

[FR 5.0: 엔딩 이후 콘텐츠]
- 히든 보스전: DB 스키마는 있지만 UI 미구현
- 무한 모드: 기획은 있지만 구현 안 됨
- PvP 모드: PvPMatch 모델만 있고 실제 대전 로직 없음

→ 이 부분들은 MVP 이후 단계별로 추가하면 될 것 같습니다.

[카드 매칭 게임]
- API는 만들어뒀는데 프론트 UI는 미완성
- 드래그 앤 드롭 라이브러리 필요할 듯

[실시간 기능]
- 현재는 REST API만 있고, WebSocket 없음
- PvP 구현하려면 Socket.io 필요

[이미지 / 사운드]
- 보스 이미지는 URL 필드만 있고 실제 이미지 없음
- 효과음, 배경음악 전혀 없음
- 설정에서 사운드 토글은 있지만 실제 작동 안 함

[테스트]
- 단위 테스트, 통합 테스트 전혀 없음
- Jest나 Vitest 세팅 필요

[성능 최적화]
- 통계 API가 매번 실시간 집계해서 느릴 수 있음
- 캐싱이나 집계 테이블 고려 필요
- 프론트엔드에서 React.memo, useMemo 등 최적화 안 함

[배포]
- Docker 컨테이너화 안 됨
- CI/CD 파이프라인 없음
- 프로덕션 빌드 설정 미흡


11. 코드 구조 및 스타일
-----------------------

[백엔드]
- MVC 패턴 유사하게 구성
- models: 데이터 스키마
- controllers: 비즈니스 로직
- routes: 라우팅
- middleware: 공통 처리
- utils: 유틸리티 함수

각 파일은 단일 책임 원칙에 따라 분리했습니다.

[프론트엔드]
- 페이지 단위로 분리
- 공통 컴포넌트는 없고 페이지에 다 때려박음 (리팩토링 필요)
- 상태 관리는 Zustand store로 분리
- API 호출은 services 레이어로 분리
- 타입은 types/index.ts에 모두 모음

TailwindCSS 유틸리티 클래스 많이 사용해서 CSS 파일은 거의 없어요.

[네이밍]
- 변수/함수: camelCase
- 컴포넌트/타입: PascalCase
- 파일명: camelCase (컴포넌트는 PascalCase)
- API 엔드포인트: kebab-case


12. 개발 중 어려웠던 점
------------------------

1) 전투 플로우 관리
턴제 전투라 상태 관리가 복잡했어요. phase를 'difficulty', 'question', 'defense'
등으로 나눠서 관리했는데, 처음엔 꼬이더라고요. 결국 명확한 상태 전이도를 그려서
해결했습니다.

2) 비동기 타이밍
API 호출 후 HP 업데이트하고, 2초 딜레이 주고, 다음 턴으로... 이 타이밍 맞추는 게
까다로웠어요. setTimeout 남발하다가 나중에 정리했습니다.

3) TypeScript 타입 정의
처음엔 any 남발했는데, 나중에 하나씩 타입 지정하면서 에러 많이 잡았어요.
특히 API 응답 타입 맞추는 게 시간 걸렸습니다.

4) MongoDB 집계 쿼리
통계 API에서 난이도별, 액션별로 집계하는 쿼리 작성이 어려웠어요.
find + filter 조합으로 우선 구현하고, 나중에 aggregate로 바꿔야 할 것 같습니다.


13. 테스트 방법
---------------

[로컬 환경 구동]

1. MongoDB 실행 (로컬 또는 Atlas)

2. 환경변수 설정
   .env 파일 생성:
   ```
   PORT=5000
   MONGODB_URI=mongodb://localhost:27017/idiom-learning
   JWT_SECRET=my-secret-key-123
   ```

3. 의존성 설치
   ```
   npm install
   cd client && npm install
   ```

4. 데이터베이스 초기화
   ```
   node server/utils/seedData.js
   ```
   → 사자성어 50개, 스테이지 12개 자동 생성

5. 개발 서버 실행
   ```
   npm run dev
   ```
   → 백엔드 5000번, 프론트엔드 5173번 포트에서 구동

6. 브라우저에서 http://localhost:5173 접속

[기능 테스트 시나리오]

1) 회원가입 → 로그인
   - 이메일: test@test.com
   - 비밀번호: 123456
   - 닉네임: 테스트사자

2) 학습 모드
   - 중급 난이도 선택
   - 빈칸 맞추기 10문제 풀기
   - 정답/오답률 확인

3) 게임 모드
   - Stage 1 (쥐신) 선택
   - 초급 난이도로 공격
   - 방어 문제 풀기
   - 보스 처치까지 반복
   - 클리어 확인

4) 통계
   - 전체 통계 확인
   - 난이도별 정확도 확인

5) 설정
   - 사운드 토글
   - 저장 확인


14. Git 브랜치 전략
-------------------

- main: 클린 상태 (README, LICENSE만)
- feature/idiom-dataset: 사자성어 JSON 데이터
- test: 전체 구현 코드 (현재 브랜치)

향후 개발 시:
- feature/* : 기능별 브랜치
- develop : 개발 통합 브랜치
- main : 프로덕션


15. 마무리
----------

요구사항 정의서의 핵심 기능들은 대부분 구현했습니다. 특히 특허의 핵심인
'학습 성과 데이터 기반 데미지 연산' 로직은 명세서대로 충실히 구현했어요.

물론 부족한 부분도 많습니다:
- 테스트 코드 없음
- 에러 처리 부족
- 성능 최적화 안 됨
- UI/UX 디테일 부족
- 이미지/사운드 없음

하지만 MVP로서 전체적인 플로우는 작동하고, 확장 가능한 구조로 만들었다고
생각합니다. 특히 백엔드 API는 명확하게 분리되어 있어서, 나중에 모바일 앱을
만들어도 그대로 사용할 수 있을 거예요.

프론트엔드도 컴포넌트 재사용성은 낮지만, 각 페이지의 기능은 명확하게 분리되어
있어서 리팩토링하기 쉬울 겁니다.

앞으로 개선할 점:
1. 공통 컴포넌트 분리 (Button, Card, Modal 등)
2. 에러 바운더리 추가
3. 로딩 상태 개선 (스켈레톤 UI)
4. 애니메이션 추가
5. 반응형 디자인 강화
6. 테스트 코드 작성
7. 성능 모니터링
8. 배포 자동화

전체적으로 약 4,000줄 정도의 코드로 풀스택 애플리케이션을 구현했습니다.
백엔드 45개 파일, 프론트엔드 포함해서 총 구조가 갖춰졌어요.


===============================================
끝.
===============================================
